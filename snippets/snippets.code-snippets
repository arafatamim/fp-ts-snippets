{
  "Import Task": {
    "prefix": "fpt",
    "body": [
      "import * as ${T} from \"fp-ts/Task\";"
    ],
    "description": "Imports all modules from Task as T. For use as, for example, `T.of`"
  },
  "Import TaskEither": {
    "prefix": "fpte",
    "body": [
      "import * as ${TE} from \"fp-ts/TaskEither\";"
    ],
    "description": "Imports all modules from TaskEither as TE. For use as, for example, `TE.of`"
  },
  "Import Option": {
    "prefix": "fpo",
    "body": [
      "import * as ${O} from \"fp-ts/Option\";"
    ],
    "description": "Imports all modules from Option as O. For use as, for example, `O.of`"
  },
  "Import Array": {
    "prefix": "fpa",
    "body": [
      "import * as ${A} from \"fp-ts/Array\";"
    ],
    "description": "Imports all modules from Array as A. For use as, for example, `A.head`"
  },
  "Import Function": {
    "prefix": "fpfn",
    "body": [
      "import { $0 } from \"fp-ts/function\";"
    ],
    "description": "Imports the prompted module from the function module."
  },
  "Import Pipe": {
    "prefix": "fpp",
    "body": [
      "import { pipe } from \"fp-ts/function\";"
    ],
    "description": "Imports the pipe module from the function module."
  },
  "Import Flow": {
    "prefix": "fpf",
    "body": [
      "import { flow } from \"fp-ts/function\";"
    ],
    "description": "Imports the flow module from the function module."
  },
  "Import IO": {
    "prefix": "fpio",
    "body": [
      "import * as ${IO} from \"fp-ts/IO\";"
    ],
    "description": "Imports all modules from IO as IO. For use as, for example, `IO.of`"
  },
  "Import IOEither": {
    "prefix": "fpioe",
    "body": [
      "import * as ${IOE} from \"fp-ts/IO\";"
    ],
    "description": "Imports all modules from IOEither as IOEither. For use as, for example, `IOE.of`"
  },
  "monad.fold": {
    "prefix": "fpfold",
    "body": [
      "${1|E,TE,O,IOE|}.fold(${2: leftSideFn}, ${3: rightSideFn})"
    ]
  },
  "monad.tryCatch": {
    "prefix": "fptryc",
    "body": [
      "${1|E,TE,O,IOE|}.tryCatch(${2: tryFn}, ${3: onError})"
    ]
  },
  "monad.reduce": {
    "prefix": "fpred",
    "body": [
      "${1|E,TE,O,IOE|}.reduce(${2: initialValue}, ${3: reducer})"
    ]
  }
}